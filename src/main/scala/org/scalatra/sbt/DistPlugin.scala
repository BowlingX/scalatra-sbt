package org.scalatra.sbt

import _root_.sbt._
import classpath.ClasspathUtilities
import Project.Initialize
import Keys._
import Defaults._
import io.Codec
import collection.JavaConverters._
import com.samskivert.mustache.Mustache

/**
 * A Distribution Plugin to prepare and package the application for provisioning a Server
 * Currently it's only possible to creates a zip file with a launcher script
 *
 *
 * Credits go mainly to casualjim
 *
 * @author casualjim
 * @author BowlingX (me@bowlingx.com)
 */
object DistPlugin extends Plugin {

  /**
   * Default Template configuration, all default scripts resist in ~plugin.jar/resources/scripts
   * @param launcher name of launcher script
   */
  case class TemplatesConfig(launcher: String = "launcher.mustache")

  object DistKeys {
    val dist = TaskKey[File]("dist", "Build a distribution: assemble the files, create a launcher and make an archive.")
    val stage = TaskKey[Seq[File]]("stage", "Build a distribution: assemble the files and create a launcher.")
    val assembleJarsAndClasses = TaskKey[Seq[File]]("assemble-jars-and-classes", "Assemble jars and classes")
    /**
     * Memory
     */
    val memSetting = SettingKey[String]("mem-setting", "The Xmx and Xms value")
    /**
     * Perm-Memory
     */
    val permMemSetting = SettingKey[String]("perm-mem-setting", "The Xmx and Xms value")
    /**
     * Template Configuration (file names)
     */
    val templatesConfig = SettingKey[TemplatesConfig]("templates-config", "The location of the templates needed to build a dist")
    /**
     * Templates Data, will be autogenerated by script, only overwrite if you know what you do
     */
    val templatesData = TaskKey[Map[String, Any]]("templates-data", "The context for the templates to get their data from")
    /**
     * Configuration file on server
     */
    val configurationFile = SettingKey[Option[String]]("app configuration", "Path to app configuration, will be available as system property")
    /**
     * Log4j configuration file
     */
    val logbackConfiguration = SettingKey[Option[String]]("logback-configuration", "Server path to logback configuration file (optional)")

    val distFiles = TaskKey[Seq[File]]("dist-files", "Assemble the dist files like the launcher and daemon scripts")
  }

  import DistKeys._

  val Dist = config("dist")

  // this is in WebPlugin, but we don't want to rely on WebPlugin to build
  private[this] val webappResources = SettingKey[Seq[File]]("webapp-resources")

  private def assembleWebJarsAndClassesTask: Initialize[Task[Seq[File]]] =
    (fullClasspath in Runtime, webappResources in Compile, excludeFilter in Dist, target in Dist, streams) map {
      (cp, webRes, excl, tgt, s) =>
        IO.delete(tgt)

        val resourceFiles = webRes flatMap {
          wr =>
            s.log.info("Adding " + wr + " to dist in " + tgt + "/webapp")
            val files = wr.descendantsExcept("*", excl)
            files x rebase(wr, tgt / "webapp")
        }
        doAssembleAppJarsAndClasses(cp, excl, tgt, s, IO.copy(resourceFiles))
    }

  private def doAssembleAppJarsAndClasses(cp: Classpath, excl: FileFilter, tgt: File, streams: TaskStreams, extra: Set[File] = Set.empty) = {

    val (libs, dirs) = cp.map(_.data).toSeq partition ClasspathUtilities.isArchive
    val jars = libs.descendantsExcept("*", excl) x flat(tgt / "lib")
    streams.log.info("Adding jars to " + (tgt / "lib"))
    jars foreach {
      l => streams.log.debug("Adding " + l + " to " + (tgt / "lib"))
    }
    val classesAndResources = dirs flatMap {
      dir =>
        streams.log.info("Adding " + dir + " to " + (tgt / "lib"))
        val files = dir.descendantsExcept("*", excl)
        files.get foreach {
          l => streams.log.debug("Adding " + l + " to " + (tgt / "lib"))
        }
        files x rebase(dir, tgt / "lib")
    }

    (IO.copy(jars) ++ extra ++ IO.copy(classesAndResources)).toSeq
  }

  private def distScriptsTask: Initialize[Task[Seq[File]]] =
    (name in Dist, templatesConfig in Dist, templatesData in Dist, target in Dist, sourceDirectory in Dist, streams) map {
      (nm, templates, data, tgt, src, s) =>
        Seq(
          executable(compileTemplate(src, templates.launcher, tgt / "bin" / nm, data, s.log))
        ).flatten
    }

  private val mustache = Mustache.compiler().escapeHTML(false)

  private def executable(f: Option[File]) = f map {
    ff =>
      ff.setExecutable(true, false)
      ff
  }

  private def compileTemplate(base: File, name: String, target: File, data: Map[String, Any], log: Logger) = {
    if (target.exists() || (base / name).isDirectory) None
    else {
      val loc = base / name
      log.info(loc.getAbsolutePath)
      val content =
        if (loc.exists()) {
          log.info("Using local (project) dist template " + loc)
          IO.read(loc, Codec.UTF8)
        } else {
          log.info("Using plugin bundled dist template.")
          IO.readStream(getClass.getClassLoader.getResourceAsStream("scripts/launcher.mustache"), Codec.UTF8)
        }

      val d = new java.util.HashMap[String, AnyRef]
      data foreach {
        case (k, v) => d.put(k, v.asInstanceOf[AnyRef])
      }
      log.debug("Compiling " + name + " with " + data)
      val compiled = mustache.compile(content).execute(d)
      log.info("Compiled template: " + target)
      log.debug(compiled)
      if (!target.getParentFile.exists()) target.getParentFile.mkdirs()
      IO.write(target, compiled, Codec.UTF8, append = false)
      Some(target)
    }
  }

  private def stageTask: Initialize[Task[Seq[File]]] =
    (assembleJarsAndClasses in Dist, distFiles in Dist, target in Dist, name in Dist, streams) map {
      (libFiles, otherFiles, tgt, nm, s) =>
        val logsDir = tgt / "logs"
        if (!logsDir.exists()) logsDir.mkdirs()
        libFiles ++ otherFiles ++ Seq(logsDir)
    }

  private def distTask: Initialize[Task[File]] =
    (stage in Dist, target in Dist, name in Dist, version in Dist) map {
      (files, tgt, nm, ver) =>
        val zipFile = tgt / ".." / (nm + "-" + ver + ".zip")
        val paths = files x rebase(tgt, nm)
        IO.zip(paths, zipFile)
        zipFile
    }

  val commonDistSettings = Seq(
    excludeFilter in Dist := HiddenFileFilter,
    target in Dist <<= (target in Compile)(_ / "dist"),
    sourceDirectory in Dist <<= (baseDirectory in Dist)  { s =>
      s
    },
    distFiles in Dist <<= distScriptsTask,
    stage in Dist <<= stageTask,
    stage <<= stage in Dist,
    dist in Dist <<= distTask,
    dist <<= dist in Dist,
    logbackConfiguration in Dist <<= (name in Dist)((n) => Some("/usr/share/%s/config/logback.xml" format n)),
    configurationFile in Dist <<= (name in Dist)((n) => Some("/usr/share/%s/config/application.conf" format n)),
    name in Dist <<= name(_ + "-service"),
    memSetting in Dist := "3g",
    permMemSetting in Dist := "512m",
    templatesConfig in Dist := TemplatesConfig(),
    javaOptions in Dist <++= (memSetting in Dist, permMemSetting in Dist, logbackConfiguration in Dist, configurationFile in Dist) map {
      (mem, perm, log4jFile, configFile) =>
        Seq(
          "-Xms" + mem,
          "-Xmx" + mem,
          "-XX:PermSize=" + perm,
          "-XX:MaxPermSize=" + perm,
          "-Xss4m",
          "-XX:ReservedCodeCacheSize=64m",
          "-XX:+UseConcMarkSweepGC",
          "-XX:+CMSParallelRemarkEnabled",
          "-XX:SurvivorRatio=8",
          "-XX:MaxTenuringThreshold=1",
          "-XX:CMSInitiatingOccupancyFraction=75",
          "-XX:+UseCMSInitiatingOccupancyOnly",
          "-XX:+DoEscapeAnalysis",
          "-XX:+UseParNewGC",
          "-XX:-UseBiasedLocking",
          "-XX:MaxNewSize=32m",
          "-XX:NewSize=32m",
          "-XX:+UseTLAB",
          "-Dfile.encoding=UTF-8"
        ) ++ log4jFile.map(f => Seq("-Dlogback.configurationFile=" + f)).getOrElse(Seq.empty) ++
          configFile.map(cf => Seq("-Dapp.config=" +cf)).getOrElse(Seq.empty)
    },

    /**
     * Setup template data for launcher file
     */
    templatesData in Dist <<= (mainClass, name in Dist, organization in Dist, javaOptions in Dist,
      baseDirectory in Dist, version, fullClasspath in Runtime, streams, target in Dist) map {
      (mn, nm, org, jo, bd, ver, cp, s, tg) =>
        s.log.info(tg / "lib" getAbsolutePath)
        if (mn.isEmpty) sys.error("You need to specify a main class (specify mainClass := Some(\"com.yourcompany.Main\") in build.sbt)")
        Map(
          "mainClass" -> mn.get,
          "name" -> nm,
          "organization" -> org,
          "javaOptions" -> jo.asJava,
          "version" -> ver,
          "classpath" -> classPathString(cp.map(_.data))
        )
    }
  )

  val webDistSettings = commonDistSettings ++ Seq(
    excludeFilter in Dist := "scss" | "js" || HiddenFileFilter,
    assembleJarsAndClasses in Dist <<= assembleWebJarsAndClassesTask
  )

  private def classPathString(libFiles: Seq[File]) = {

    ((libFiles filter ClasspathUtilities.isArchive) x flat) map ("\"${LIB_DIR}/%s\"" format _._2) mkString java.io.File.pathSeparator
  }
}